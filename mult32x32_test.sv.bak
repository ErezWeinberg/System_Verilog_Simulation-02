module mult32x32_test;
    logic clk;            
    logic reset;          
    logic start;          
    logic [31:0] a;       
    logic [31:0] b;       
    logic busy;           
    logic [63:0] product;

    // Add FSM state signals
    logic [1:0] a_sel;
    logic b_sel;
    logic [2:0] shift_sel;
    logic upd_prod;
    logic clr_prod;

    // Instantiate the multiplier
    mult32x32 uut (
        .clk(clk),
        .reset(reset),
        .start(start),
        .a(a),
        .b(b),
        .busy(busy),
        .product(product)
    );
    
    // Clock generation - 10ns period
    initial begin
        clk = 1'b1;
        // Run for specific time then stop
        #200 $finish;
    end

    // Clock toggle every 5ns
    always begin
        #5 clk = ~clk;
    end
    
    // Test sequence
    initial begin
        // Initialize signals
        reset = 1'b1;  // Assert reset
        start = 1'b0;  // Initialize start to 0
        a = 32'd0;     // Initialize inputs to 0
        b = 32'd0;
        
        // Hold reset for 4 clock cycles
        repeat (4) @(posedge clk);
        reset = 1'b0;  // Deassert reset
        
        // Set inputs to ID numbers
        a = 32'd322979956;  // First ID number
        b = 32'd300086550;  // Second ID number
        
        // Wait one clock cycle
        @(posedge clk);
        
        // Assert start for one clock cycle
        start = 1'b1;
        @(posedge clk);
        start = 1'b0;
        
        // Wait for busy to deassert
        wait (!busy);
        
        // Add a few cycles to observe the stable output
        repeat (2) @(posedge clk);
    end

    // Optional: Add some monitoring
    initial begin
        $monitor("Time=%0t reset=%b start=%b busy=%b product=%h", 
                 $time, reset, start, busy, product);
    end

endmodule